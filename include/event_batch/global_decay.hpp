/**
 * @file
 * @brief Global decay estimator implementation.
 */

#ifndef EVENT_BATCH_GLOBAL_DECAY_HPP
#define EVENT_BATCH_GLOBAL_DECAY_HPP

#include <cstdint>
#include <utility>

#include "event_batch/utils.hpp"

namespace event_batch
{
/**
 * @brief Event decay structure.
 */
struct __attribute__((__packed__)) Decay
{
  /**
   * @brief Previous timestamp \f$[\text{microseconds}]\f$.
   */
  uint64_t t;
  /**
   * @brief Event decay in \f$[0,1]\f$.
   */
  float decay;
  /**
   * @brief Auxiliary variable that counts the incoming number of events.
   */
  float n_decay;
  /**
   * @brief Auxiliary variable that estimates the event time decay
   * \f$[\text{microseconds}]\f$.
   */
  float t_decay;
  /**
   * @brief Estimated event rate \f$[\text{events}/\text{microseconds}]\f$.
   */
  float rate;

  /**
   * @brief Estimates the event decay.
   *
   * This method estimates the decay by estimating the event stream activity.
   *
   * @param t_cur Current timestamp \f$[\text{microseconds}]\f$.
   */
  void
  operator()(const uint64_t t_cur)
  {
    const float t_diff = (t_cur > t) ? static_cast<float>(t_cur - t) : 0;
    if (t_diff > 0)
    {
      decay =
          static_cast<float>(1) /
          (static_cast<float>(1e-6) * t_diff * n_decay + static_cast<float>(1));

      n_decay *= decay;
      t_decay = decay * t_decay + t_diff;

      t = t_cur;
    }
    else
    {
      decay = static_cast<float>(1);
    }
    ++n_decay;

    rate = n_decay / t_decay;
  }

  /**
   * @brief Resets the context.
   *
   * @param t_decay_first Initial time rate assumption to bootstrap the rate
   * estimator \f$[\text{microseconds}]\f$.
   */
  void
  reset(const uint64_t t_decay_first)
  {
    t = 0;
    decay = 1;
    n_decay = 0;
    t_decay = t_decay_first;
    rate = 0;
  }
};

/**
 * @brief Global decay estimator.
 *
 * This class estimates the decay from a stream of events generated by a single
 * motion.
 *
 * @tparam Event Type of event.
 * @tparam EventToDecay Type of the handle to pass from an event to a decay.
 * @tparam HandleDecay Type of the handle to further process the estimated
 * decay.
 */
template <typename Event, typename EventToDecay, typename HandleDecay>
class GlobalDecay
{
 public:
  /**
   * @brief Constructs an instance to estimate the global decay from a stream of
   * events.
   *
   * @param t_decay_first @copybrief t_decay_first_
   * @param event_to_decay @copybrief event_to_decay_
   * @param handle_decay @copybrief handle_decay_
   */
  GlobalDecay(const uint64_t t_decay_first, EventToDecay&& event_to_decay,
              HandleDecay&& handle_decay)
      : t_decay_first_(t_decay_first),
        event_to_decay_(std::forward<EventToDecay>(event_to_decay)),
        handle_decay_(std::forward<HandleDecay>(handle_decay))
  {
    reset();
  }
  /**
   * @brief Deleted copy constructor.
   */
  GlobalDecay(const GlobalDecay&) = delete;
  /**
   * @brief Default move constructor.
   */
  GlobalDecay(GlobalDecay&&) = default;
  /**
   * @brief Deleted copy assignment operator.
   */
  GlobalDecay&
  operator=(const GlobalDecay&) = delete;
  /**
   * @brief Default move assignment operator.
   */
  GlobalDecay&
  operator=(GlobalDecay&&) = default;
  /**
   * @brief Default destructor.
   */
  ~GlobalDecay() = default;

  /**
   * @brief Estimates the global decay one event at a time.
   *
   * This method estimates the decay in an event-by-event basis by estimating
   * the event stream activity.
   *
   * @param event Incoming event.
   */
  void
  operator()(Event event)
  {
    decay_(event.t);
    handle_decay_(event_to_decay_(event, decay_.decay, decay_.n_decay,
                                  decay_.t_decay, decay_.rate));
  }

  /**
   * @brief Resets the context.
   */
  void
  reset()
  {
    decay_.reset(t_decay_first_);
  }

 protected:
  /**
   * @brief Initial time rate assumption to bootstrap the rate estimator
   * \f$[\text{microseconds}]\f$.
   */
  const uint64_t t_decay_first_;

  /**
   * @brief Decay stucture.
   * \sa event_batch::Decay.
   */
  Decay decay_;

  /**
   * @brief Handle to pass from an event to a decay.
   */
  EventToDecay event_to_decay_;
  /**
   * @brief Handle to further process the estimated decay.
   */
  HandleDecay handle_decay_;
};

/**
 * @brief Make function that creates an instance of event_batch::GlobalDecay.
 *
 * @tparam Event Type of event.
 * @tparam EventToDecay Type of the handle to pass from an event to a decay.
 * @tparam HandleDecay Type of the handle to further process the estimated
 * decay.
 *
 * @param t_decay_first Initial decay assumption to bootstrap the rate
 * estimator \f$[\text{microseconds}]\f$.
 * @param event_to_decay Handle to pass from an event to to a decay.
 * @param handle_decay Handle to further process the estimated decay.
 *
 * @return Instance of event_batch::GlobalDecay.
 */
template <typename Event, typename EventToDecay, typename HandleDecay>
inline GlobalDecay<Event, EventToDecay, HandleDecay>
make_global_decay(const uint64_t t_decay_first, EventToDecay&& event_to_decay,
                  HandleDecay&& handle_decay)
{
  return GlobalDecay<Event, EventToDecay, HandleDecay>(
      t_decay_first, std::forward<EventToDecay>(event_to_decay),
      std::forward<HandleDecay>(handle_decay));
}
}  // namespace event_batch

#endif  // EVENT_BATCH_GLOBAL_DECAY_HPP
